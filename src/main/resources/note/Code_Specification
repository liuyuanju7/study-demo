1.  千万不要使用为被初始化的变量;--对于未知对象的使用，要注意判空处理 防止空指针异常

2.  final 表示常量，--只能被赋值一次，不能再被更改，一般 常量名使用全大写， 可以将实例域定义为final，构建对象时必须初始化，且不能够
    再进行修改；大多应用于 基本类型域 或 不可变类型域
    static final 类常量， 可以在一个类中的多个方法中使用
    static 静态域 ，每个类只有一个静态域 即使 对象不存在 类的静态域也存在， 每一个实例对象 对于静态域都有一份自己的拷贝
    不要使用对象调用静态方法

3.  ++n  n++ , 前缀方式先进行 +1运算， 后缀方式则使用原来的值 ，不建议在表达式内部使用，易混淆， ++运算符改变了变量的值，
    所以操作数 不能是 数值 4++ 错误;

4.  && || 逻辑与 逻辑或 !逻辑非 都是短路方式运算的，如果第一个操作数已经能够确定表达式的值，就不会再继续计算了

5.  不要在boolean类型与任何数值类型之间进行强制类型转换， 防止发生错误，极少数情况下，可以使用三元表达式 expre ？ 1 ： 0

6. \ 表示反斜杠 文件名中含有 \ 需要在前额外再加一个 反斜杠

7.  方法参数分为：按值传递 和 按引用传递，属于函数调用时参数的求值策略，这是对调用函数时，求值和传值的方式的描述，而非传递的内容的类型
                                                                        (内容指：是值类型还是引用类型，是值还是指针)
    求值策略        求值时间        传值方式
    值传递          调用前          值的结果（原值的副本 拷贝）
    引用传递         调用前         原值（原始对象，无副本 拷贝）

    Java采取的都是 按值传递 方法得到的是所有参数值的一个拷贝,Java，所以说Java是Pass by value，原因是它调用时Copy，实参不能指向
                                            另一个对象，而不是因为被传递的东西本质上是个Value，这么讲计算机上什么不是Value?
    Java中方法参数使用的情况：1）一个方法不能修改一个基本数据类型的参数
                          2）一个方法可以改变一个对象参数的状态（对象参数 其实就是 对象的引用的副本 指向对一个对象 ，
                                 引用不会改变，但可以通过引用 改变 引用指向的对象）
                          3）一个方法不能让对象参数应用一个新的对象

8.  局部变量初始化时 必须明确值， 而类中的域 如果没有被初始化，将会被初始化为默认值（0 false null）

9.  调用构造器的具体处理步骤：（静态域（块） 会在类第一次加载的时候 进行初始化）
    1）所有数据域被初始化为默认值（0 false null)
    2）按照类声明中出现的顺序，一次执行所有域初始化语句和初始化块
    3）如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
    4）执行这个构造器主体本身

10. 在比较两个枚举类的值的时候，不需要调用equals 直接使用 ==， toString 方法可以返回 枚举常量名

11. a.method(b) 隐式参数 指方法名前 及调用方法的对象 在方法中 可以通过this 代表， 显式参数 方法名括号中的参数

12. 访问权限修饰符         当前类   package   子类   其他package
               public     1         1       1       1
            protected     1         1       1
      default(frendly)    1         1                       (不写时  为此种情况)
              private     1

13. 接口中方法 默认均为 只能为 public ，只能声明 public static final 的常量，两者习惯性不写，接口默认，
    在接口中声明常量 是在其实现类 需要频繁使用某一个常量值时，可以声明在接口里
    final ： 接口是高级的抽象，所以其中的域是 其实现类共享的，所以需要保证其 只读不可写的 性质
    static ： Java中类 是可以同时实现多个接口的(，隔开)，当两个接口 拥有同一个变量名时，static 常量就可以，通过A.name B.name区分

14.对象Clone , Object 内部的 clone方法为 protected 类型的，只能克隆对应对象自身类型的， 而且为浅克隆：只能克隆 基本类型的域
    和 不可变类型的对象，一般对于要是用clone方法的对象，要实现Cloneable 接口，重写clone方法实现深克隆

15. @link: java\demo\innerclass   //待进一步研究
    普通内部类 可以用public等修饰符 ，可以使用外部类的 成员
    局部内部类 不可以，只作用于局部，对外部而言是隐藏的，既可以访问外部类 还可以访问局部变量， 但局部变量必须声明为final
    匿名内部类：只创建这个类的一个对象，就不必命名 ： 需要一个某个接口的实现类
    静态内部类：不需要访问外部类，只为了隐藏，可以声明为static ,以便取消引用 : 同是计算数组中的最大最小值并返回

16. 异常 Throwable ： Error ，Exception
    Error： Java运行时系统的内部错误和资源耗尽错误，不应该抛出，除告知用户，并尽力使程序安全终止外 无能为力
    Exception ： 由程序导致的异常属于RuntimeException（未检查异常），而程序本身没有问题而是像I/O错误，属于其他异常（已检查异常）

    子类方法抛出的异常不能 高于父类方法中抛出的
    自定义异常 ： 派生与Exception 或其子类，习惯上带有两个构造器 默认 和 带有详细信息参数的

    建议独立使用 try/catch try/finally, finally 中的return 值 会覆盖 try中的 return值
    带资源的 try 语句, 会自动关闭资源，不用担心处理 在finally语句中关闭资源可能出现的异常
    try(Scanner in = new Scanner(new FileInputStream("/file")){
        code ..

    }
